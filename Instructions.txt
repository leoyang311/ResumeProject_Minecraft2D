
CHANGES FROM HOMEWORK 6 SOLUTIONS
=================================
I have made these improvements and modifications to the code provided for
Homework 6:
* The Gradle file has the changes mentioned on Piazza for building on Macs.
* There are no longer spurious INFO messages on startup.
* The program exits when the Player dies.
* Text is printed to the Run pane as well as the text area of the game board.
* There is a new method LivingEntity.isInFightingRange(Entity) to check if the
  two entities are within fighting range.
* Minor changes have been made to attack() and takeDamage() in LivingEntity,
  including to their signatures and what they output.
* There is a new Mob class: Spider.
* There is a new class Spawner and a new interface Damageable, which you will
  need to complete.
* The tick() method from Zombie has been removed because I found the "Zombie
  groans" messages annoying. Feel free to add them back.

SETUP
=====
I strongly recommend that you add the OS-appropriate string to the
run configuration, as detailed in a video on the Canvas Homework 9 page.
* Windows: -Dorg.openrndr.exceptions=JVM
* Mac: -Dorg.openrndr.exceptions=JVM -XstartOnFirstThread

TIPS
====
* If you get a strange compiler error, such as "Changes are not tracked,
  unable determine incremental changes.", do Gradle > Tasks > build > clean.
* If you get strange run-time errors, do Gradle > Tasks > build > clean.
* Otherwise, build by clicking on the green triangle on the top of IntelliJ.
* Ignore warnings about Gradle versions as long as your project runs.
* If the game grid uses up too much of your screen for you to see the
  messages, in the text area, do any of the following:
  - Change the constant NUM_ROWS in Homework9Game.
  - View the text in IntelliJ's Run pane.
* After generating the KDoc, copy it to a directory where it won't get
  deleted if you run "Gradle > Tasks > build > clean", and open it in a
  browser.
* You can print debugging messages using Game.addText().
* You may find it useful to call clearText() from Game.tick().

Problem 1: selectAdjacentEmptyCell()
====================================
Create a new method in Entity with this KDoc and signature:

    /**
     * Returns the position of an empty cell adjacent to this entity or
     * `null` if no such cell exists or if this entity is not on the board.
     */
    fun selectAdjacentEmptyCell(): Position?

For full credit, it needs to behave as described. It does not need to
select an adjacent cell randomly. For example, it is fine if it always
chooses the position to the left if it is available. You do need to
include the KDoc above your code.

Problem 2: Damageable
=====================
Right now, the takeDamage() method is in LivingEntity. You will be creating
a new type of Entity that is not a LivingEntity but will be capable of taking
damage. We have provided a new interface named Damageable as a starting point.

1. Move the KDoc for takeDamage() from LivingEntity to Damageable. Remove all
   references to properties, since they will not necessarily apply. Replace
   the word "hearts" with "units", since not all entities have hearts.
2. Immediately below the KDoc, put the signature of the method. That means
   that subclasses will have to provide an implementation of the method.
3. In LivingEntity, indicate that it implements the Damageable interface
   and that takeDamage() overrides a method. (You may need to refer to lecture
   notes for how to do this.)  When you override or implement a method declared
   elsewhere, you should not provide KDoc.
4. We want it to be possible to attack anything that is Damageable, so, in
   LivingEntity, change the type of the attack() parameter to Damageable.
5. Make the corresponding change to the attack() parameter in Mob.
6. Make sure your code still compiles and runs and that living entities can
   still take damage and be killed.
7. Generate the KDoc and look at the page for LivingEntity. See how it
   indicates that LivingEntity implements the Damageable interface and what
   it shows for takeDamage().

Problem 3: SpiderSpawner
========================
You will create a SpiderSpawner that randomly creates Spiders that appear in
empty adjacent cells. Watch the video for this problem on the Canvas page to
see the expected behavior.

1. Create a class SpiderSpawner that is a subclass of Entity. It should have
   no parameters. Use the provided Spawner image ("SpawnerOnSand.png").
   Don't forget to add KDoc (a brief description of the class). You should
   regenerate and view the KDoc to make sure it appears properly.
2. Create a private method spawn() that checks for an adjacent empty
   cell using selectAdjacentEmptyCell(). If it finds one, it constructs a
   Spider and places it at the returned Position.
3. Add a private (non-parameter) property "spawnProbability", which should
   be a Double in the range 0-1, indicating the probability of spawning a
   spider on each turn. For example, if it is .75, the per-turn probability
   would be 75%. You can choose the value.
4. Create a method tick() so that on each turn, it generates a random number
   between 0 and 1. If spawnProbability > the random number, have it call
   spawnSpider(). (I don't care whether you use > or >= for the comparison,
   as long as you are consistent.) For debugging purposes, have tick() and
   spawn() call Game.addText() with messages indicating the value of
   the random number and (if spawnSpider() is called) whether an empty
   adjacent cell was found and a spider spawned.
5. Modify the init block in Game to randomly place a SpiderSpawner on the
   board. Run the program and make sure it behaves as expected. You should
   see turns in which a Spider is spawned and turns in which they are not.
   Copy the transcript into Summary.txt.
6. Modify the init block in Game to place the SpiderSpawner at (0, 0), and
   place other entities so they block it in, as shown in the video. Make sure
   it behaves as expected (not spawning spiders when there is no adjacent
   cell). Copy the transcript into Summary.txt.

Problem 4: Make SpiderSpawner Damageable
========================================
In Problem 3, you created indestructible SpiderSpawners. In this problem, you
will make them Damageable. Watch the video for this problem on the Canvas page
to see the expected behavior.

1. Add a private mutable property "hardness", which should be an Int of your
   choice greater than 0, such as 6.
2. Modify the top of SpiderSpawner to indicate that it will implement the
   Damageable interface.
3. Implement the method takeDamage(). It should print appropriate messages
   and reduce the value of the hardness. When hardness reaches 0, it should
   call an appropriately named private method that you create that prints a
   message saying the spawner has been destroyed and removes it from the
   game. As a reminder, private methods do not require KDoc.
4. Right now, Player only attacks nearby aggressive Mobs. Change it so that it
   also attacks all nearby non-Mobs that are Damageable. Make sure to exclude
   the Player or it will attack itself! Also make sure the names of your
   methods are accurate.
5. Test your code to make sure the Player can destroy a SpiderSpawner and save
   the transcript to Summary.txt.

Problem 5: Spawner<T>
=====================
In this problem, you will complete a generic version of Spawner so you are able
to construct Spawners for different types of Mobs. Do not delete SpiderSpawner,
which you should keep for reference and grading.

1. Examine the provided class Spawner<T>. Note that the constructor takes two
   arguments:
   * The name of the entity type. This enables it to create its own type string
     (e.g., "Spider Spawner") to pass to the Entity constructor.
   * A no-argument function that constructs a new instance of the mob class
     whenever it is called. The provided method makeNewMob() shows how to call
     it.
2. Add these parameters to the constructor and make them properties:
   * spawnProbability (Double)
   * hardness (Int)
3. Modify the class header to Spawner<T> to show that it will implement the
   interface Damageable.
4. Copy all the methods from SpiderSpawner, removing references to "Spider".
   Wherever the string "Spider" was used, use the property "mobType". Wherever
   a Spider was constructed, call makeNewMob() (or invoke mobBuilder() directly).
5. Make Spawner open so it can be extended (subclassed).

Problem 6: ZombieSpawner
========================
For this part, you will create a ZombieSpawner that is a subclass of
Spawner<Zombie>.  Watch the video for this problem on the Canvas page
to see the expected behavior.

1. Create a new class "ZombieSpawner" that extends Spawner<Zombie>.
   The new class constructor should take no parameters, but it should
   pass the necessary arguments to the Spawner<Zombie> constructor.
   These are:
   * the name of the class being spawned ("Zombie")
   * an anonymous function of no arguments that returns a new Zombie
   * spawnProbability (you can choose the value)
   * hardness (you can choose the value)
   You should not need to provide any code.
2. Add code to the init block of Game to create and randomly place a
   ZombieSpawner.
3. Test out the game and make sure the Zombie Spawner
   * spawns Zombies
   * generates appropriate output
   * can be destroyed
   It would be wise to decrease Zombie's attack strength or increase
   Player's numHearts for testing purposes. You don't need to change
   them back.

Problem 7: Adding another Spawner
=================================
That was a lot work, but now it is easy to add other spawners. Create a
spawner for an existing Mob or add a new Mob. You can get a picture of a Mob
from the Minecraft Wiki [https://minecraft.fandom.com/wiki/Mob] and convert it
from webpng to a 64x64 png online [https://cloudconvert.com/webp-to-png].

Add your new Spawner subclass to the game and make sure it works.

Problem 8: Create a ZombieSpawnerSpawner
========================================
You should now be able to create a ZombieSpawnerSpawner: a Spawner that creates
ZombieSpawners. This should take only a few lines of code. Test that it works.


SUBMISSION INSTRUCTIONS
=======================
Answer the usual questions in Summary.txt.

Create a PDF with all of the files that you changed except for Game.kt. These
should include:
* Damageable.kt
* Entity.kt
* LivingEntity.kt
* Mob.kt
* Player.kt
* Spawner.kt
* SpiderSpawner.kt
* ZombieSpawner.kt
* ZombieSpawnerSpawner.kt
* Summary.txt
